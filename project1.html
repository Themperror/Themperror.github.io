<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta property="og:image" content="./assets/images/avatar.png">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://Themperror.github.io/">
		<meta property="og:title" content="Themperror's Portfolio">
		<meta property="og:description" content="Game/Engine Programmer">

		
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<title>Themperror's Portfolio</title>

		<!-- <link href="./assets/foundation-icons.css" rel="stylesheet"> /-->
		<link href="https://cdnjs.cloudflare.com/ajax/libs/foundicons/3.0.0/foundation-icons.css" rel="stylesheet">

		<link rel="stylesheet" href="./assets/main.css">
		<link rel="stylesheet" href="./assets/layout.css">
		<link rel="stylesheet" href="./assets/monokai.min.css">

		<link rel="shortcut icon" href="favicon.png">
	</head>
	<body>
		<script src="./assets/scripts/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous">
		</script>

		<div id="main" class="container">
			<div class="container header" id="mainHeader">
				<canvas class="headerCanvas" id="disp"></canvas>

				<div class="avatar">
					<div class="round-image pop" style="background-image: linear-gradient(rgba(229, 223, 197, 0.5), rgba(229, 223, 197, 0.4)), url(&#39;./assets/images/avatar.png&#39;);" title="Me">
					</div>
				</div>
				<div class="container">
					<h1 class="title"><b>Themperror</b></h1>
					<h4 class="sub-title">Game/Engine Programmer</h4>
					<div class="social">
						<a class="fi-social-github menu-btn" href="https://github.com/Themperror" title="GitHub"></a>
						<a class="fi-mail menu-btn" href="mailto:themperror1@gmail.com" title="E-Mail"></a>
					</div>
				</div>
			</div>
			<div class="container">
			<h2 id="welcome">
				<a href="index.html">Back to Home.</a>
			</h2>
			<section>
				<h2 id="skills">ThempX11</h2>
				<h3><a class="link" href="https://github.com/Themperror/ThempX11">Link to the Github.</a></h3>
				<section class="sub-card">
					<h3>Type</h3>
					<p class="tab">Tech Demo / Renderer</p>
					<h3>Language</h3>
					<p class="tab">C++</p>
					<h3>API's</h3>
					<p class="tab">D3D11</p>
					<h3>Libraries</h3>
					<p class="tab">"<a href="https://github.com/ocornut/imgui">Dear Imgui</a>" as Debug UI</p>
					<h3>Comments</h3>
					<p class="tab">Made from scratch.<br>Written tools to export images in .DDS (using DirectXTex) and models in my own custom format (Using Assimp).</p>
				</section>
				<p id="projects"> This was one of the two 6-month long project that were part of my final study year. The initial goal was to focus on shadowing techniques but after I implemented the first one, the decision to add PBR was quickly added as well.</p>
				<p id="projects"> The scene is created with a <b>deferred renderer</b>, meaning I first render all the geometry to a few rendertargets which is called a <b>G(eometry)-Buffer.</b></p>
				<p><br><br>Click on images to view the full versions.</p>
				<div class="hcontainer">
					<a target="_blank" href="./assets/images/x11Diffuse.jpg">
						<div class="imgcard">
							<img src="./assets/images/x11Diffuse.jpg">
						</div>
					</a>
					<a target="_blank" href="./assets/images/x11Normals.jpg">
						<div class="imgcard">
							<img src="./assets/images/x11Normals.jpg">
						</div>
					</a>
					<a target="_blank" href="./assets/images/X11Pos.jpg">
						<div class="imgcard">
							<img src="./assets/images/X11Pos.jpg">
						</div>
					</a>
					<a target="_blank" href="./assets/images/X11f0.jpg">
						<div class="imgcard">
							<img src="./assets/images/X11f0.jpg">
						</div>
					</a>
					<a target="_blank" href="./assets/images/X11Misc.jpg">
						<div class="imgcard">
							<img src="./assets/images/X11Misc.jpg">
						</div>
					</a>
					<a target="_blank" href="./assets/images/X11depth.jpg">
						<div class="imgcard">
							<img src="./assets/images/X11depth.jpg">
						</div>
					</a>
				</div>
				<p id="projects">My G-Buffer exists out of the following data (left to right):<br>-Diffuse,<br>-World Normals,<br>-World Position,<br>-F0 (Index of Refraction),<br>-Misc (R: Roughness, G: Metallicness, B: EmissiveStrength, A: isEmissive), <br>-Depth.</b></p>		
				<p id="projects"><br>After this step I calculate the shadows for all the lights, for Point Lights I use something called <b>Single Pass Render-to-Cubemap</b>, which uses geometry shaders to work on multiple viewports at once, rather than doing every face one by one.</p>
				<p id="projects"><br>For Directional Lights I had implemented a few types of shadowing, this being the normal shadowmapping and <b>PCF</b> (including multisampled variants) and <b>Cascaded Shadow Mapping</b> which wasn't completely finished yet as it still suffers from swimming edges due to the light not moving in pixel-space.</p>
				<p id="projects"><br>I also used a technique from DOOM <a href="http://www.adriancourreges.com/blog/2016/09/09/doom-2016-graphics-study/">(which can be found here)</a> called Shadow Map Atlassing.</p>
				<div class="imgcard">
					<img src="./assets/images/X11shadowatlas.jpg">
				</div>
				<p id="projects"><br>I wrote a simple command&conquer algorithm to reserve space in the shadow atlas for each light so I could simply call "ObtainTextureArea(size)" which would obtain a suitable area for the light to render to.</p>
				
				<p id="projects"><br>For PBR I used sources from all over the place, most notably LearnOpenGL.com which has a nice guide on PBR, though a bit incomplete in my opinion so the PBR is a quite standard implementation.<br>Sadly <a href="https://google.github.io/filament/Filament.md.html">Google's Filament</a>  guide didn't exist yet when I was working on it as it's a godly source for PBR.</p> 
				
				<p id="projects">The scene is composed out of the extracted models from the Elemental Demo, which can be found on the Unreal Engine's Marketplace. Sadly as all the PBR related information is done on the materials inside the engine, all I got exported was the diffuse and normal maps. I wrote my own material system in order to gain some control of all the values and manually made a texture describing the PBR info per material. I am no artist however so if something looks off that's probably my fault with creating the textures.<br>Final result looks like this:</p> 
				<a target="_blank" href="./assets/images/X11.jpg">
					<div class="fullimage">
						<img src="./assets/images/X11.jpg">
					</div>
				</a>
		</div>
	</div>

	<script src="./assets/scripts/navigo.js"></script>
	<script src="./assets/scripts/showdown.js"></script>
	<script src="./assets/scripts/highlight.min.js"></script>

	<script type="text/javascript">
		var mainHeader = document.getElementById("mainHeader");
		var canvas = document.getElementById("disp");
		var ctx = canvas.getContext("2d");

		window.onresize = function() 
		{
			canvas.width = window.innerWidth;
			canvas.height = mainHeader.clientHeight;
		};
		window.onresize();

		var MAX_PARTICLES = 512;
		var particles = [];

		for (var i = 0; i < MAX_PARTICLES; i++) 
		{
			particles.push(
			{
				x: 0,
				y: 0,
				z: 0,
				vx: 0,
				rand : 0,
				dead: true
			});
		}

		function redraw()
		{
			ctx.globalCompositeOperation = "source-over";
			ctx.fillStyle = "rgb(21, 21, 21, 0.5)";
			ctx.fillRect(0, 0, canvas.width, canvas.height);

			ctx.globalCompositeOperation = "lighter";
			ctx.fillStyle = "rgba(229, 223, 197, 0.5)";
			var t = time
			for (var i = 0; i < MAX_PARTICLES; i++) 
			{
				var p = particles[i];
				if (p.dead) continue;

				ctx.beginPath();
				ctx.arc(p.x, p.y  + Math.sin(p.rand + t * 0.1) * 10, p.z, 0, Math.PI * 2);
				ctx.fill();
			}
		}

		var time = 0;
		function emit() 
		{
			var p = null;
			for (var i = 0; i < MAX_PARTICLES; i++)
			{
				if (particles[i].dead) 
				{
					p = i;
					break;
				}
			}

			if (p === null) return;

			particles[p].dead = false;
			particles[p].x = -10;
			particles[p].y = 5 + Math.random() * (canvas.height - 10);
			particles[p].z = (Math.random() + 0.5) * 1.0;
			particles[p].vx = (Math.random() + 0.2) * 5.0;
			particles[p].rand = Math.random();
			particles[p].wave = Math.random() >= 0.5;
		}
		function update()
		{
			var t = time++ % 35;
			if(t == 0 )
			{	
				emit();
				emit();
			}

			for (var i = 0; i < MAX_PARTICLES; i++) 
			{
				var p = particles[i];
				if (p.dead) continue;
				p.x += p.vx;

				if (p.x > canvas.width+2 || p.y > canvas.height+2)
					p.dead = true;
			}
		}

		function loop() 
		{
			update();
			redraw();
			window.requestAnimationFrame(loop);
		}

		loop();
	</script>
</body></html>